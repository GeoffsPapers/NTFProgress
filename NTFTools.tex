\documentclass[runningheads]{llncs}

\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage{amsmath,amssymb}
\renewcommand\UrlFont{\color{blue}\rmfamily}
% \renewcommand{\arraystretch}{0.8}
\renewcommand{\floatpagefraction}{0.9}
\renewcommand{\textfloatsep}{2.0ex}
\renewcommand{\dbltextfloatsep}{2.0ex}
\setlength{\tabcolsep}{3pt}
\newenvironment{packed_itemize}{
\vspace*{-0.5em}
\begin{itemize}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{1pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
}{\end{itemize}}

\begin{document}

\title{TPTP World Infrastructure \\ for Non-classical Logics}
\titlerunning{The Non-classical TPTP World}

\author{Alexander Steen\inst{1}\orcidID{0000-0001-8781-9462} 
\and
Geoff Sutcliffe\inst{2}\orcidID{0000-0001-9120-3927}}
\authorrunning{A. Steen, G. Sutcliffe}
\institute{University of Greifswald, Germany \\
\email{alexander.steen@uni-greifswald.de}
% \url{https://www.alexandersteen.de} 
\and
University of Miami, USA \\
\email{geoff@cs.miami.edu}
% \url{https://www.cs.miami.edu/home/geoff/} 
}

\maketitle
%--------------------------------------------------------------------------------------------------
\begin{abstract}
The TPTP World is a well established infrastructure that supports research, 
development, and deployment of Automated Theorem Proving (ATP) systems.
The development of the TPTP World has until now focused on classical logic, while many 
real-world applications of ATP also require non-classical reasoning. 
This paper describes the latest extension of the TPTP World, providing languages, problems,
solutions, and infrastructure for non-classical logics.
These are the keys steps towards releasing TPTP v9.0.0, with normal modal logic problems.

\keywords{TPTP World \and Non-classical logic.}
\end{abstract}
%--------------------------------------------------------------------------------------------------
\section{Introduction}
\label{Introduction}

The TPTP World \cite{Sut17} is a well established infrastructure that supports research, 
development, and deployment of Automated Theorem Proving (ATP) systems.
The TPTP World includes the TPTP problem library,
% \cite{Sut09}, 
the TSTP solution library,
% \cite{Sut10}, 
standards for writing ATP problems and reporting ATP solutions,
% \cite{SS+06,Sut08-KEAPPA}, 
tools and services for processing ATP problems and solutions,
% \cite{Sut10}, 
and it supports the CADE ATP System Competition (CASC).
% \cite{Sut16}.
Various parts of the TPTP World have been deployed in a range of applications,
in both academia and industry.
The web page \href{https://www.tptp.org}{\tt www.tptp.org} provides access to all 
components.

The development of the TPTP World has until now focused on classical logic, while many 
real-world applications of ATP also require non-classical reasoning. 
These applications include artificial intelligence (e.g., knowledge representation, planning, 
multi-agent systems), philosophy (e.g., formal ethics, metaphysics), natural language semantics 
(e.g., generalized quantifiers, modalities), and computer science (e.g., software and hardware 
verification).
This paper describes the latest extension of the TPTP World, providing languages and
infrastructure for reasoning in non-classical logics \cite{Pri08,Gob01}.
The non-classical logics supported so far are
normal modal \cite{FM98},
alethic modal \cite{Sch06-CPL},
deontic \cite{Hil71},
epistemic \cite{vDH15},
doxastic \cite{Hin62}, and
instant-based temporal \cite{GR22}.
In this paper the languages and infrastructure are exemplified in normal modal logic \cite{BBW06},
as will be used in problems in TPTP v9.0.0.

\paragraph{Paper structure:}
Section~\ref{TPTPLanguages} provides the key features of the TPTP languages for writing
non-classical problems and solutions. 
Section~\ref{TPTP} describes the collection of non-classical problems for the TPTP problem library, 
and Section~\ref{TSTP} the collection of solutions to such problems in the TSTP solution library.
Section~\ref{SystemsTools} gives an overview of ATP systems and tools for non-classical logics.
Section~\ref{Conclusion} concludes, including plans for further development of the non-classical
TPTP World.

%--------------------------------------------------------------------------------------------------
\section{The Non-classical TPTP Languages}
\label{TPTPLanguages}

The TPTP languages for first-order clause normal form (CNF) \cite{SS98-JAR}, full first-order 
form (FOF) \cite{Sut09}, typed-first order form (TFF) \cite{SS+12,BP13-TFF1}, and typed 
higher-order form (THF) \cite{SB10,KSR16} are by now well known and regularly documented.
An overview that is relevant to this paper is provided in \cite{SF+22}, and the detailed
syntax of the languages is given in an extended BNF\footnote{%
\label{BNF}\href{https://www.tptp.org/TPTP/SyntaxBNF.html}{\tt www.tptp.org/TPTP/SyntaxBNF.html}} 
\cite{VS06}.
As a simple reminder, here is an example of a monomorphic typed extended first-order (TX0) 
annotated formula~\ldots
\[
\begin{minipage}{\textwidth}
\begin{verbatim}
    tff(leaf_knaves_lie,axiom,
        ! [I: inhabitant,S: $o] : 
          ( ( is_knave(I) & says(I,S) ) => ~ S ),
        file('PUZ081_8.p',knaves_lie),
        [description('Knaves always lie'), relevance(0.9)]).
\end{verbatim}
\end{minipage}
\]

The non-classical typed extended first-order form (NXF) and non-classical typed higher-order 
form (NHF) languages are the TPTP languages for non-classical logics.
They are respectively based on the typed extended first-order (TXF) and typed higher-order (THF)
languages, and correspondingly have mono\-morphic (NX0, NH0) and polymorphic (NX1, NH1) variants.

The non-classical connectives of NXF and NHF have the form {\tt \{\$}{\em name}{\tt \}}.
Examples are {\tt \{\$box\}} ($\Box$ in logic texts), {\tt \{\$dia\}} ($\Diamond$ in logic texts), 
{\tt \{\$possible\}}, {\tt \{\$necessary\}}, {\tt \{\$obligatory\}}, {\tt \{\$permissible\}}, 
{\tt \{\$knows\}}, {\tt \{\$believes\}}, etc.
A connective may optionally be parameterized to reflect more complex non-classical connectives,
e.g., in multi-modal logics where the modal operators are indexed, in epistemic logics
where the knowledge operators can specify the agents under consideration,
and in dynamic logics \cite{HKT00} where the connectives are parameterized with (complex) programs.
The form is
{\tt \verb|{|\$}{\em name}{\tt (}{\em param$_1$}{\tt ,}{\em \ldots}{\tt ,}{\em param$_n$}{\tt )}{\tt \verb|}|}.
If the connective is indexed the index is given as the first parameter prefixed with a {\tt \#},
e.g., {\tt \{\$knows(\#manuel)\} @ (nothing)}\footnote{%
As in \href{https://www.youtube.com/watch?v=ISD86-oM4Ow}{\tt www.youtube.com/watch?v=ISD86-oM4Ow}}.
All other parameters are key-value assignments.
There are also short form unary connectives for unparameterised $\Box$ and $\Diamond$: {\tt [.]} 
and {\tt <.>}, e.g., $\Box p$ can be written {\tt [.] p}.

In NXF the non-classical connectives are applied in a mixed 
``higher-order applied''/``first-order functional'' style, with the connectives applied to a
{\tt ()}ed list of arguments.\footnote{%
This slightly unusual form was chosen to reflect the first-order functional style, but by making
the application explicit the formulae can be parsed in Prolog -- a long standing principle of the
TPTP languages \cite{SZS04}.}
In NHF the non-classical connectives are applied in usual higher-order style, with curried 
function applications using the application operator {\tt @}.
Full specification of the connectives and their use in formulae is in the 
BNF
% \footnotemark[\ref{BNF}] 
starting at {\tt <nxf\_atom>} and {\tt <thf\_defined\_atomic>}.
Figure~\ref{NX0Example} shows example types and alethic modal logic formulae in NX0 (the
{\tt semantics} formula is explained next).

In non-classical logics the same language can be used for formulae while different logics are 
used for reasoning.
It is therefore necessary to provide \mbox{(meta-)} information that specifies the
logic to be used.
A TPTP annotated formula with the role \texttt{logic} is used for this, with a ``logic 
specification'' as the formula.
A logic specification consists of a defined logic (family) name identified with a list of 
properties (note, the property names have been improved since their presentation in \cite{SF+22}).
The {\tt \$domains} property specifies whether each quantification domain is constant, varying,
cumulative, or decreasing, across the accessibility relation.
The {\tt \$designation} property specifies whether symbols are interpreted rigidly, i.e., 
interpreted as the same domain element in every world, or flexibly, i.e., possibly interpreted 
as different domain elements in different worlds. 
The {\tt \$terms} property specifies whether interpretation is local to the current world or
global to all worlds.
The {\tt \$modalities} property specifies properties of the connectives, either as a well-known 
logic system, e.g., the modal system {\bf S5}, or as axiom schemes, e.g., the modal axiom {\bf 5} 
as in \cite{Gar18}.
Further details of the logic specifications are in \cite{SF+22}.
Figure~\ref{NX0Example} shows a logic specification in NX0.

\begin{figure}[h!]
\small
\setstretch{0.9}
\begin{verbatim}
%------------------------------------------------------------------------
tff(semantics,logic,
    $alethic_modal == [
      $constants == $rigid,
      $quantification == $constant,
      $modalities == $modal_system_M ] ).

tff(fruit_type,type,   fruit: $tType).
tff(apple_decl,type,   apple: fruit).
tff(banana_decl,type,  banana: fruit).
tff(healthy_decl,type, healthy: fruit > $o).
tff(rotten_decl,type,  rotten: fruit > $o).

%----Apples are different from bananas
tff(apple_not_banana,axiom,
    apple != banana ).

%----All fruit are necessarily healthy
tff(necessary_healthy_fruit_everywhere,axiom,
    ! [F: fruit] : ( {$necessary} @ (healthy(F)) ) ).

%----All fruit are possibly not rotten
tff(fruit_possibly_not_rotten,axiom,
    ! [F: fruit] : ( {$possible} @ (~ rotten(F)) ) ).

%----Bananas are rotten in the conjecture's (local) world
tff(rotten_banana_here,axiom-local,
    rotten(banana) ).

%----Try prove that is necessary for apples to be healthy and bananas 
%----to be not rotten. Impossible because bananas are rotten locally.
tff(not_true,conjecture,
    ( {$necessary} @
      (( healthy(apple)
       & ~ rotten(banana) )) ) ).
%------------------------------------------------------------------------
\end{verbatim}
\caption{NX0 example}
\label{NX0Example}
\end{figure}

%--------------------------------------------------------------------------------------------------
\section{TPTP Problems}
\label{TPTP}

The TPTP problem library of test problems for ATP systems has been extended in v9.0.0 to include
problems in monomodal normal modal logic using the NX0 and NH0 languages.\footnote{%
The numbers of problems are unknown at the time of writing, but by the time of release it will
be in the 100s, not 1000s.}
To start with, problems in monomodal normal modal logic are being collected, including problems 
from (the citations are just some examples)
books \cite{For94,FM98,Gir00,Sid10}, 
conference and journal papers \cite{Rei92,FH+98,Sto00,PN+21}, 
and 
use cases \cite{BW14-ECAI,MR22}.

The headers of the non-classical logic problems include relevant augmented information:
\begin{packed_itemize}
\item The {\tt Syntax} field includes the number of non-classical connectives that are not indexed,
      and the number that are indexed.
      For example, the problem in Figure~\ref{NX0Example} has four non-indexed connectives and
      no indexed connectives, written ``{\tt 4 \{.\};   0 \{\#\}}'' in the header field.
\item The {\tt SPC} (Specialist Problem Class\footnote{%
      The problems in the TPTP library are divided into Specialist Problem Classes (SPCs) – 
      classes of problems that are homogeneous wrt recognizable logical, language, and syntactic 
      characteristics}) field has values for non-classical logic problems. 
      For example, the SPC of the problem in Figure~\ref{NX0Example} is {\tt NX0\_THM\_NEQ\_NAR} 
      -- it's in the NX0 language, is a theorem, and there is no use of equality or arithmetic.
\end{packed_itemize}

The files in the {\tt Documents} directory have been correspondingly augmented:
\begin{packed_itemize}
\item The {\tt TFFSynopsis}, {\tt THFSynopsis}, and {\tt OverallSynopsis} files give the numbers 
      of non-classical logic problems.
\item The {\tt ProblemAndSolutionStatistics} file gives the numbers of non-classical
      connectives in each problem.
\end{packed_itemize}

%--------------------------------------------------------------------------------------------------
\section{TSTP Solutions}
\label{TSTP}

The TSTP solution library \cite{Sut07-CSR} contains solutions to TPTP problems, from a wide range
of ATP systems.
The TPTP format for derivations \cite{SS+06} can immediately be used for writing derivations in
non-classical logic.
The new TPTP format for interpretations \cite{SS+23-LPAR} can be used to write Kripke models.
The TSTP contains solutions for the non-classical problems in the TPTP (see Section~\ref{TPTP}), 
from the ATP systems for non-classical logic available in the TPTP World (see
Section~\ref{ATPSystems}).
However, at the time of writing none of the systems output their solutions in TPTP format in
the non-classical language (Leo-III outputs its proofs in TPTP format, but the proofs are
in the language of the embedded problems - TF0 or TH0 \cite{SS+23}.

ZZZZZZZZZZZZ
Four new defined symbols are used in Kripke interpretation-formulae:
\begin{packed_itemize}
\item A defined type {\tt \$world} is used for the worlds of the interpretation.
      Different constants of type {\tt \$world} are known to be unequal (but as yet no ATP 
      systems implement that, so it's necessary to encode that explicitly using inequalities of 
      the {\tt \$distinct} predicate).
\item A defined predicate {\tt \$accessible\_world} of type {\tt (\$world~*~\$world)~>~\$o}
      is used to specify the accessibility relation between worlds.
\item A defined constant {\tt \$local\_world} of type {\tt \$world~>~\$o} is used to specify 
      the world in which a local (the default) conjecture is to be proved. 
\item A defined predicate {\tt \$in\_world} of type {\tt (\$world~*~\$o)~>~\$o} is used to 
      specify the interpretations in the worlds.
      The boolean argument means the interpretation-formulae are necessarily written in TXF or THF.
\end{packed_itemize}
A Kripke interpretation-formula is a conjunction of specification of the worlds,
distinctness of the worlds,
the accessibility relation,
the local world if any,
for each world, its Tarskian interpretation (also in the new TPTP format for interpretations).
The interpretation-formulae are preceded by the necessary type declarations.
Figure~\ref{NX0Kripke} shows the worlds and the first world's Tarskian interpretation for 
a Kripke model in NX0, for the problem in Figure~\ref{NX0Example}.
The second world is the same except that bananas are not rotten.

\begin{figure}[h!]
\small
\setstretch{0.9}
% tff(fruit_type,type,fruit: $tType).
% tff(apple_decl,type,apple: fruit).
% tff(banana_decl,type,banana: fruit).
% tff(healthy_decl,type,healthy: fruit > $o).
% tff(rotten_decl,type,rotten: fruit > $o).
\begin{verbatim}
%------------------------------------------------------------------------
tff(d_fruit_type,type,d_fruit: $tType).
tff(d2fruit_decl,type, d2fruit: d_fruit > fruit ).
tff(d_apple_decl,type,d_apple: d_fruit).
tff(d_banana_decl,type,d_banana: d_fruit).

tff(w1_decl,type,w1: $world).
tff(w2_decl,type,w2: $world).

tff(fruity_worlds,interpretation,
%----There are two worlds, w1 and w2
    ( ( ! [W: $world] : ( W = w1 | W = w2 )
%----The conjecture was disproved in world w1
      & $local_world = w1
%----World accessibility is reflexive, and ws ir accessible from w1
      & $accessible_world(w1,w1)     %----Logic is M
      & $accessible_world(w2,w2)
      & $accessible_world(w1,w2) )
%----Tarskian interpretation in world w1
    & $in_world(w1,
%----There are two fruit in the domain, apple and banana
        ( ( ! [F: fruit] : ? [DF: d_fruit] : F = d2fruit(DF)
          & ! [DF: d_fruit] : ( DF = d_apple | DF = d_banana )
          & $distinct(d_apple,d_banana)
%----The terms are local
          & ? [DP: d_fruit] : ( DP = d_apple )
          & ? [DP: d_fruit] : ( DP = d_banana )
%----The type-promotion is reflexive
          & ! [DF1: d_fruit,DF2: d_fruit] :
              ( d2fruit(DF1) = d2fruit(DF2) => DF1 = DF2 ) )
%----The constant apple is interpreted as the domain element
        & ( apple = d2fruit(d_apple)
%----The constant banana is interpreted as the domain element
          & banana = d2fruit(d_banana) )
%----Apples and bananas are healthy
        & ( healthy(d2fruit(d_apple))
          & healthy(d2fruit(d_banana))
%----Apples are not rotten, bananas are rotten in the local world w1
          & ~ rotten(d2fruit(d_apple))
          & rotten(d2fruit(d_banana)) ) ) )
%------------------------------------------------------------------------
\end{verbatim}
\caption{NX0 Kripke model example}
\label{NX0Kripke}
\end{figure}

%--------------------------------------------------------------------------------------------------
\section{Software Support}
\label{SystemsTools}

A range of software support has been developed, and continues to be developed, to support
access to and manipulation of non-classical logic problems, ATP systems, solutions, and
processing tools.

%--------------------------------------------------------------------------------------------------
\subsection{Parsers}
\label{Parsers}

The TPTP World utilities TPTP4X and TPTP2T \cite{Sut07-CSR,Sut10}, and the BNF-based suite
of parsers \cite{VS06}, work with TPTP format non-classical problems and problem data.
TPTP4X parses problems, can apply various transformations, and pretty-prints the formulae.
TPTP2T selects problems and solutions with specified syntactic and semantic characteristics,
e.g., it could be used to list non-classical problems in NXF that are theorems, contain equality,
and are easy to prove.
The BNF-based parsers offer stricter parsing than TPTP4X, and can present the parse trees in
various forms.
All these tools are freely available from GitHub\footnote{%
\href{https://github.com/TPTPWorld}{\tt github.com/TPTPWorld}}, and in SystemOnTPTP.

In addition to the TPTP World's own tools, a suite of tools that can read and manipulate 
problems written in NXF and NHF is available in the Leo-III framework \cite{SB21}.
At the front end, the {\tt tptp-utils} tool \cite{Ste22-TU} for pre- and post-processing TPTP 
problems (in all the TPTP languages) can be used on NXF and NHF problems.
It does syntax checking, translations, generation of parse trees, and (basic) linting.
For NXF and NHF in particular, it can sanity check logic specifications for modal logics.
Its underlying parser written in Scala, which is also used by Leo-III, is available as the 
stand-alone parsing library {\tt scala-tptp-parser} \cite{Ste21}.
It supports parsing all TPTP languages, including NXF and NHF.
It comes with a complete definition of abstract syntax trees for the internal representation 
of TPTP input, and a fully TPTP-compliant pretty-printer. 

%--------------------------------------------------------------------------------------------------
\subsection{Translators}
\label{Parsers}

As a stepping stone into ATP for NXF and NHF problems, the NTFLET Logic Embedding Tool 
\cite{Ste22-LE} does a shallow embedding of NXF problems into TXF or THF, and NHF problems
into THF \cite{BP13,BR13,GSB17,GS18}.
By default NTFLET produces TX0 or TH0, but it can optionally produce polymorphic TH1 or TX1
(which can be significantly shorter if the input problem contains many user types).
Currently NTFLET supports a range of modal logics, a range of first-order quantified hybrid 
logics, public announcement logic, and two different dyadic deontic logics.
Any TPTP-compliant TXF/THF ATP system to be added as a backend to NTFLET to form an 
ATP system for NXF/NHF.
This is done internally in Leo-III \cite{SB21,Ste22}.

%--------------------------------------------------------------------------------------------------
\subsection{ATP Systems}
\label{ATPSystems}

ATP for non-classical logics is a well established endeavour (particularly for propositional
non-classical logics), but there are significantly fewer ATP systems available than for classical 
logics.
The ATP systems that we know about are
K\raisebox{-3pt}{S}P \cite{NHD20,PN+21}, nanoCoP-M \cite{Ott21}, MleanCoP \cite{Ott14}, 
MetTeL2 \cite{TSK12}, Leo-III \cite{SB21}, LoTREC \cite{FF+01}, and MSPASS \cite{HS00-TABLEAUX}.
Leo-III can used on NXF and NHF problems natively, via the embedding approach described below.
As noted there, any TPTP-compliant TXF/THF ATP system can replace Leo-III as the backend after
the embedding, thus offering a suite of system variants.
For the TPTP World, front-ends have been added to K\raisebox{-3pt}{S}P, nanoCoP-M, and MleanCoP,
to translate NXF problems to the systems' input syntax so that they can be used on TPTP
format problems.
All these systems are available in SystemOnTPTP\footnote{%
\href{https://www.tptp.org/cgi-bin/SystemOnTPTP}{\tt www.tptp.org/cgi-bin/SystemOnTPTP}}.
Sadly, at the time of writing, there are no ATP systems that output TPTP format proofs or 
Kripke models for non-classical logic problems (which were hopefully given in TPTP format).

%--------------------------------------------------------------------------------------------------
\subsection{Verifiers}
\label{Verifiers}

The TPTP World has several tools for processing proofs and models in non-classical logic.
Although there are no ATP systems that output TPTP format proofs for non-classical problems yet, the
GDV derivation verifier \cite{Sut06} is able verify such proofs.
Similarly, the IDV Interactive Derivation Viewer \cite{TPS07} is able to display such proofs.
The AGMMV model verifier can verify Kripke models given in a NXF-based Kripke interpretation
representation format.

%--------------------------------------------------------------------------------------------------
\subsection{Online}
\label{Online}

TPTP2T \cite{}

SystemB4TPTP, SystemOnTPTP, SystemOnTSTP

The IIV Interactive Interpretation Viewer \cite{MS23-Poster} can be used to interact with the
Tarskian interpretations within the worlds of a Kripke model. 
A wrapper to view the worlds and accessibility relationship of a Kripke model is being developed,
which will be linked to IIV to view a chosen world's Tarskian interpretation.
GDV, IDV, AGMMV, and IIV are all available in SystemOnTPTP.

The Leo-III tools are also available in SystemOnTPTP.

%--------------------------------------------------------------------------------------------------
\section{Conclusion}
\label{Conclusion}

This paper describes the latest extension of the TPTP World, providing languages and
infrastructure for reasoning in non-classical logics.
That includes the NXF and NHF languages with non-classical connectives, and a new type of
of formula for specifying the logic to be used for reasoning.
The NXF and NHF languages are used for writing problems in non-classical logics, and the
TPTP format for writing Kripke interpretations is introduced.
ATP systems that can reason in non-classical logic, particularly those that can read 
problems written in TXF and THF, are listed, and tools for manipulating formulae written in 
NXF and NHF are described.
Altogether, this paper has described the keys steps towards releasing TPTP v9.0.0,
with modal logic problems.

Ongoing and future work includes~\ldots
\begin{packed_itemize}
\item Collecting lots more problems in non-classical logics.
\item Working with ATP system developers to upgrade their systems to natively read problems 
      written in NXF and NHF, and to produce proofs and models in NXF or NHF.
\item Optimizing the NTFLET embeddings to automatically recognize language fragments for which
      TXF embedding is possible.
\item Producing an interactive viewer for Kripke interpretations written in TPTP-format.
\item Standardizing the embedding of further specific non-classical logics in NXF/NHF (including
      choosing connective names, and allowed parameters of the logic specification).
\item A non-classical division of CASC.
\end{packed_itemize}

%--------------------------------------------------------------------------------------------------
\bibliographystyle{splncs04}
\bibliography{Bibliography}
%--------------------------------------------------------------------------------------------------
\end{document}
